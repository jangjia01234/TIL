# [Authentication] 인증 & 인가

### 강경훈 멘토님

<br>

> [Westudy - Authentication](https://study.wecode.co.kr/session/121) 참고

<br>

## 목차

- 인증, 인가의 정의와 절차
- 세션 기반 / 토큰 기반 인증의 차이점
- 인증 절차에 필요한 암호화의 종류, 각 특징
- Bcrypt란
- JWT

<br>

---

## 인증 (Authentication)

- 대상이 실제로 맞는지를 결정하는 과정
- 사요자의 자격 증명 정보(ex. id, pw)와 데이터베이스의 정보가 일치하면 액세스 권한을 제공(ex. 로그인)
- 유형
  - SFA(단일 요소 인증): id, pw만 요구
  - 2FA(2단계 인증): 코드/지문 등 추가 인증 요구
  - MFA(다중 요소 인증): 3개 이상의 신원 확인 요소 요구
- 절차
  - 회원가입
    - 서버는 가입때 입력한 사용자의 Id,pw를 db에 저장
    - 단, pw와 같이 민감한 정보는 암호화해서 저장
  - 로그인
    - 가입때 입력한 id, pw를 사용자가 입력
    - 사용자가 입력한 정보와 DB에 저장된 정보 비교
    - 정보 일치하면 사용자 인증 정보를 전송
    - 로그인 후 다음 요청부터는 서버로부터 받은 인증 정보를 같이 첨부해서 서버로 전송

<br>

## 인가 (Authorization)

- "인증은 했는데, 어느 정도까지의 권한을 허용할 것인가?"
- 사용자에게 특정 리소스 / 기능에 대한 액세스 권한을 부여하는 절차
- 사용자에게 권한 부여를 위해서는 항상 인증 절차를 진행함
- 인증 절차 후 조직의 관리자는 요청된 리소스에 대한 액세스 권한을 부여함
- ex
  - 누군가에게 서버의 특정 파일을 다운받을 수 있는 권한 부여
  - 개별 사용자에게 서비스 관리 액세스 권한 제공

<br>

## Session vs Token 기반 인증

### Intro

- 웹 환경에서 사용자와 시스템 간 데이터 교환을 위해 HTTP 방식 사용
- 각각의 HTTP 통신(요청/응답)은 독립적이기에 과거의 통신에 대한 내용을 전혀 모르는 Stateless 상태를 유지함
- 과거의 통신 내용을 모르기에 매 통신마다 필요한 모든 정보를 담아서 요청을 보내야 함

### 세션과 쿠키

- 세션

  - 클라이언트(사용자)가 브라우저로 웹서버에 접속한 시점부터 브라우저를 종료해 연결을 끝내는 시점 동안 클라이언트와 웹서버가 논리적으로 연결된 상태
  - 서버는 세션 정보를 저장하고 클라에게는 세션을 구분할 수 있는 세션 ID를 부여
  - 클라이언트 Request를 보낼 때 해당 세션 ID를 함께 보냄으로써 클라의 상태를 확인
  - ex. Database session에서 봤던 id값을 생각하면 됨

  - 장점: 세션 ID를 잘 돌려줌
  - 단점: 사용자 수가 늘어날수록 서버에 가해지는 부하가 증가

- 쿠키

  - 클라이언트의 컴퓨터에 저장되는 데이터 파일
  - 이름, 값, 만료 날짜/시간(저장기간), 경로 정보 등으로 구성
  - 하나의 도메인당 20개를 가질 수 있고, 1개당 4Kbyte를 넘길 수 없음
  - 클라이언트는 HTTP Request에 저장된 Cookie를 함께 전달하여 이전의 통신에서 사용된 정보를 파악
  - 쿠키를 이용해 ㄴ로그인을 하지 않은 상태로 장바구니에 상품 담기 가능
  - 사용자별로 다른 정보를 표시하거나 행동/패턴을 분석할 수 있음

- 토큰
  - 토큰을 갖고 있으면 티켓처럼 해당 서비스를 이용할 수 있는 권리가 있다고 낙주
  - 제한된 리소스에 관해 일정 기간 동안 접근할 수 있는 권한을 캡슐화
  - scale out 매우 주의!
- 우리는 세션 말고 토큰 방식으로 인증 절차를 진행할 것임!

## 암호화

- 암호화: 못 뚫는다 (X) 뚫는 시간을 지연시킨다 (O)

### 단방향 암호화

    - 한쪽 방향으로만 암호화가 됨. 복호화(복구) 안됨.
    - 한계: 해킹 방법이 있음 (해시 함수에 대한 정해진 테이블(레인보우 테이블)을 기준으로 다 찔러보면서 해킹 가능)

### 솔팅 & 키 스트레칭

- Salting
  - 원본 데이터에 랜덤한 데이터를 추가
    데이터가 추가되어 원본과 다른 해시 값을 가짐
- Key Stretching
  - 해시를 여러번 반복, 해시값을 다시 해시하는 방식으로 진행
  - 1초에 5번 비교

### 양방향 암호화 - 대칭키

- 대칭키 암호화란?
  - 복호화 가능
    암호화 알고리즘을 키를 이용해서 사용한 키가 동일한 암호 시스템
- 단점

  - 상대방도 사전에 같은 키를 가지고 있어야 함

- 비대칭키 암호화란?
  - 암호화 / 복호화할 때 사용하는 키가 다름

여기까지는 완전 이론, 그 뒤부터는 나중에 써야할 내용

---

### Bcrypt

- 대표적인 단방향 암호화, 솔팅과 키 스트레칭이 적용됨
- 구조 이미지 참고
- 유저가 입력한 값을 그대로 해시했을 때 이 값과 비교하는지를 판단
  -> 해시값과 기존의 암호화된 값을 비교하여 검증을 진행

### JWT

- JWT (JSON Web Token)
  - 클라이언트(사용자)와 서버 간에 정보를 JSON(JabaScript Object Notation) 개체로 안전하게 전송하기 위한 개방형 표준
  - Headed, Payload, Siganture로 구성되어 있음
  - 전자 서명이 되어있기 때문에 신뢰할 수 있음
  - 데이터를 숨기는 게 아니라 신뢰성을 보장하는 게 목적
  - 서버에서 세션 정보를 저장하기 위해 세션 스토리지나 DB에 완전히 의존할 필요가 없음
  - 서버의 확장성과 멀티 기기 및 도메인에서 활용하기 좋음

<br>

- Header

  - JWT의 첫번쨰 구성요소, 두가지 정보를 담고있음

- Payload (여기가 중요)
  - 실제로 토큰을 통해 전달할 정보를 담는 곳
  - Payload에 담긴 정보 하나하나를 Claim이라고 함 (Claim = key)
  - Public Claims (JWT 사용자들이 공개적으로 정의한 Claim) / Private Claims (사용자와 서버 사이에서만 합의하여 사용함)
- Signature
  - 서명을 나타내는 부분
  - 시그니처 부분은 우리가 볼 수 없음 (암호화됨) -> JWT를 만들때 사용한 key가 있어야지만 볼 수 있음
  - 전달받은 토큰의 H와 P를 서버의 시크릿키를 이용해 암호화 -> 해당 값이 전달받은 시그니처와 같은지 비교해서 JWT의 신뢰성 확인
  - 서버에서 관리하는 시크릿키가 아닌 다른 키로 JWT를 발급했다면 시그니처가 달라짐
